1:"$Sreact.fragment"
2:I[54596,["822","static/chunks/822-fe6c23912db2e7f0.js","177","static/chunks/app/layout-cfedc8fcf31c4563.js"],"default"]
3:I[91799,[],""]
4:I[26731,[],""]
5:I[2683,["774","static/chunks/774-0e066eddd2320794.js","891","static/chunks/891-704d620be23b8ddd.js","655","static/chunks/app/react-concepts/hooks/page-8a92ee3d227859b1.js"],"ReactConceptPageLayout"]
b:I[4925,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/665ae8a03fa26bca.css","style"]
6:Tbd6,# React Hooks

Hooks are functions that let you "hook into" React state and lifecycle features from function components.

## Basic Hooks

### useState

Manages local state in functional components.

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
}
```

### useEffect

Handles side effects in functional components.

```jsx
function DataFetcher() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('/api/data')
      .then((res) => res.json())
      .then(setData);
  }, []); // Empty dependency array = run once
}
```

## Hooks Flow

```mermaid
graph TD
    A[Component Renders] --> B[useState Initializes]
    B --> C[useEffect Runs]
    C --> D[State Updates]
    D --> E[Component Re-renders]
    E --> F[useEffect Cleanup]
```

## Rules of Hooks

1. **Only call hooks at the top level**
2. **Only call hooks from React functions**
3. **Hook names must start with "use"**

## Custom Hooks

```jsx
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value) => {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.log(error);
    }
  };

  return [storedValue, setValue];
}
```

## Hook Dependencies

Understanding when hooks re-run is crucial:

```jsx
// Runs after every render
useEffect(() => {
  console.log('Effect runs every time');
});

// Runs only once after initial render
useEffect(() => {
  console.log('Effect runs once');
}, []);

// Runs when count changes
useEffect(() => {
  console.log('Effect runs when count changes');
}, [count]);

// Runs when count or name changes
useEffect(() => {
  console.log('Effect runs when count or name changes');
}, [count, name]);
```

## Common Hook Patterns

### Form Handling

```jsx
function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const reset = () => setValues(initialValues);

  return { values, handleChange, reset };
}
```

### API Calls

```jsx
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchData = useCallback(async () => {
    setLoading(true);
    try {
      const response = await fetch(url);
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [url]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
}
```
8:T1aa1,# Custom Hooks

## Building Reusable Logic

Custom hooks let you extract component logic into reusable functions.

```jsx
function useDataFetching(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await fetch(url);
      if (!response.ok) throw new Error('Network response was not ok');
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [url]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
}
```

## Advanced Hook Patterns

### useReducer for Complex State

```jsx
function useCounter(initialState = 0) {
  const [state, dispatch] = useReducer(counterReducer, initialState);

  const increment = () => dispatch({ type: 'INCREMENT' });
  const decrement = () => dispatch({ type: 'DECREMENT' });
  const reset = () => dispatch({ type: 'RESET' });

  return { count: state, increment, decrement, reset };
}

function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT':
      return state - 1;
    case 'RESET':
      return 0;
    default:
      return state;
  }
}
```

### useCallback and useMemo

```jsx
function ExpensiveComponent({ items, onItemClick }) {
  // Memoize expensive calculation
  const expensiveValue = useMemo(() => {
    return items.reduce((acc, item) => acc + item.value, 0);
  }, [items]);

  // Memoize callback to prevent unnecessary re-renders
  const handleClick = useCallback(
    (item) => {
      onItemClick(item);
    },
    [onItemClick]
  );

  return (
    <div>
      <p>Total: {expensiveValue}</p>
      {items.map((item) => (
        <button key={item.id} onClick={() => handleClick(item)}>
          {item.name}
        </button>
      ))}
    </div>
  );
}
```

## Hook Composition

```mermaid
graph LR
    A[Custom Hook] --> B[State Logic]
    A --> C[Effect Logic]
    A --> D[Event Handlers]
    B --> E[Component State]
    C --> F[Side Effects]
    D --> G[User Interactions]
```

## Advanced Hooks

### useRef for DOM Access

```jsx
function useFocus() {
  const inputRef = useRef(null);

  const focus = useCallback(() => {
    inputRef.current?.focus();
  }, []);

  return { inputRef, focus };
}

function InputWithFocus() {
  const { inputRef, focus } = useFocus();

  return (
    <div>
      <input ref={inputRef} placeholder="Type here..." />
      <button onClick={focus}>Focus Input</button>
    </div>
  );
}
```

### useImperativeHandle for Parent-Child Communication

```jsx
const FancyInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus(),
    blur: () => inputRef.current.blur(),
    select: () => inputRef.current.select(),
  }));

  return <input ref={inputRef} {...props} />;
});

function Parent() {
  const inputRef = useRef();

  const handleFocus = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <FancyInput ref={inputRef} />
      <button onClick={handleFocus}>Focus</button>
    </div>
  );
}
```

### useLayoutEffect for Synchronous Updates

```jsx
function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useLayoutEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return size;
}
```

## Testing Custom Hooks

```jsx
import { renderHook, act } from '@testing-library/react';

test('useCounter increments count', () => {
  const { result } = renderHook(() => useCounter(0));

  act(() => {
    result.current.increment();
  });

  expect(result.current.count).toBe(1);
});

test('useCounter respects initial value', () => {
  const { result } = renderHook(() => useCounter(5));

  expect(result.current.count).toBe(5);
});
```

## Hook Best Practices

### 1. Keep Hooks Focused

```jsx
// ❌ Bad: Too many responsibilities
function useUser() {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  const [settings, setSettings] = useState({});
  // ... many more states
}

// ✅ Good: Single responsibility
function useUser() {
  const [user, setUser] = useState(null);
  // ... only user-related logic
}

function useUserPosts() {
  const [posts, setPosts] = useState([]);
  // ... only posts-related logic
}
```

### 2. Use Descriptive Names

```jsx
// ❌ Bad: Unclear purpose
function useData() { ... }

// ✅ Good: Clear purpose
function useUserProfile() { ... }
function usePostComments() { ... }
```

### 3. Handle Cleanup Properly

```jsx
function useInterval(callback, delay) {
  useEffect(() => {
    const id = setInterval(callback, delay);

    // Always return cleanup function
    return () => clearInterval(id);
  }, [callback, delay]);
}
```

### 4. Optimize with useCallback/useMemo

```jsx
function useExpensiveCalculation(data) {
  return useMemo(() => {
    return data.reduce((acc, item) => {
      // Expensive calculation here
      return acc + complexCalculation(item);
    }, 0);
  }, [data]);
}
```

## Hook Libraries

### React Hook Form

```jsx
import { useForm } from 'react-hook-form';

function Form() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();

  const onSubmit = (data) => console.log(data);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('firstName', { required: true })} />
      {errors.firstName && <span>This field is required</span>}
      <button type="submit">Submit</button>
    </form>
  );
}
```

### React Query

```jsx
import { useQuery } from '@tanstack/react-query';

function Posts() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts,
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      {data.map((post) => (
        <Post key={post.id} post={post} />
      ))}
    </div>
  );
}
```

## Performance Considerations

- **Dependency Arrays**: Always include all reactive values
- **Object/Array Dependencies**: Use useMemo to prevent unnecessary re-renders
- **Function Dependencies**: Use useCallback for stable references
- **Cleanup Functions**: Prevent memory leaks and stale closures
- **Hook Order**: Never call hooks conditionally or in loops
0:{"P":null,"b":"eFKoBWCIQvl-oibIJIPHZ","p":"","c":["","react-concepts","hooks",""],"i":false,"f":[[["",{"children":["react-concepts",{"children":["hooks",{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/665ae8a03fa26bca.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":[["$","head",null,{"children":["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css"}]}],["$","body",null,{"className":"__className_e8ce0c","children":[["$","div",null,{"className":"layout","children":[["$","$L2",null,{}],["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]]}],["$","script",null,{"src":"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"}],["$","script",null,{"src":"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n            // Initialize highlight.js\n            if (typeof hljs !== 'undefined') {\n              hljs.highlightAll();\n            }\n            \n            // Initialize mermaid\n            if (typeof mermaid !== 'undefined') {\n              mermaid.initialize({ \n                startOnLoad: true,\n                theme: 'default',\n                flowchart: { useMaxWidth: true }\n              });\n            }\n          "}}]]}]]}]]}],{"children":["react-concepts",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["hooks",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":[["$","$L5",null,{"title":"React Hooks","description":"Master React hooks: useState, useEffect, useContext, and custom hooks.","conceptGuide":"$6","interactiveComponent":"$L7","furtherExploration":"$8"}],null,"$L9"]}],{},null,false]},null,false]},null,false]},null,false],"$La",false]],"m":"$undefined","G":["$b",[]],"s":false,"S":true}
c:I[48574,[],"OutletBoundary"]
e:I[9779,[],"AsyncMetadataOutlet"]
10:I[48574,[],"ViewportBoundary"]
12:I[48574,[],"MetadataBoundary"]
13:"$Sreact.suspense"
7:["$","div",null,{"className":"text-center","children":[["$","h3",null,{"className":"text-lg font-semibold mb-4","children":"Hooks Demo"}],["$","div",null,{"className":"space-y-4","children":["$","div",null,{"className":"p-4 bg-muted rounded","children":["$","p",null,{"className":"text-sm text-muted-foreground","children":"Interactive hooks demonstration will go here"}]}]}]]}]
9:["$","$Lc",null,{"children":["$Ld",["$","$Le",null,{"promise":"$@f"}]]}]
a:["$","$1","h",{"children":[null,[["$","$L10",null,{"children":"$L11"}],["$","meta",null,{"name":"next-size-adjust","content":""}]],["$","$L12",null,{"children":["$","div",null,{"hidden":true,"children":["$","$13",null,{"fallback":null,"children":"$L14"}]}]}]]}]
11:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
d:null
f:{"metadata":[["$","title","0",{"children":"React Binary Search - Algorithm Study Guide"}],["$","meta","1",{"name":"description","content":"Learn React concepts and binary search algorithms through interactive examples"}],["$","meta","2",{"name":"author","content":"React Binary Search Team"}],["$","meta","3",{"name":"keywords","content":"React,Algorithms,Binary Search,TypeScript,Learning"}]],"error":null,"digest":"$undefined"}
14:"$f:metadata"
